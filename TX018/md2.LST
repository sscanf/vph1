CCS PCM C Compiler, Version 2.717, 9374

               Filename: Z:\MD2\MD2.LST

               ROM used: 160 (16%)
                         Largest free fragment is 864
               RAM used: 16 (24%) at main() level
                         22 (32%) worst case
               Stack:    2 locations

0000:  MOVLW  00
0001:  MOVWF  0A
0002:  GOTO   042
0003:  NOP
....................  /////////////////////////////////////////////////////// 
.................... // 
.................... // PROGRAMA PARA EL MODEM RM018 
.................... //--------------------------------------------------------- 
.................... // 
.................... // Parametros para el compilador: +FM +t 
.................... // 
.................... //  
.................... //////////////////////////////////////////////////////////// 
....................  
.................... #include <y:\picc\examples\16f84.h> 
....................  //////// Standard Header file for the PIC16F84 device //////// 
.................... #device PIC16F84 
.................... #list 
.................... 
.................... //#include <y:\picc\examples\16c54.h> 
.................... #include <y:\picc\examples\ctype.h> 
....................  ////        (C) Copyright 1996,1997 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... #list 
.................... 
.................... #include <y:\picc\examples\stdlib.h> 
....................  ////        (C) Copyright 1996,1997 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _stdlib_ 
....................  
.................... #define _stdlib_ true 
....................  
.................... float atof(char * s) { 
.................... 	float pow10; 
....................         float result; 
.................... 	int sign, point; 
.................... 	char c; 
....................         int ptr; 
....................  
....................         ptr=0; 
....................    	sign = 0; 
.................... 	point = 0; 
.................... 	pow10 = 1.0; 
....................    	result = 0.0; 
....................  
.................... 	do 
....................           c=s[ptr++]; 
....................         while ((c<'0'||c>'9') && c!='+' && c!='-' && c!='.'); 
....................  
.................... 	while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................            if(c == '-') { 
....................               sign = 1; 
....................               c = s[ptr++]; 
....................            } 
....................  
....................            while((c >= '0' && c <= '9') && point == 0) { 
....................               result = 10*result + c - '0'; 
....................               c = s[ptr++]; 
....................            } 
....................  
....................            if (c == '.') { 
....................               point = 1; 
....................               c = s[ptr++]; 
....................            } 
....................  
.................... 	   while((c >= '0' && c <= '9') && point == 1) { 
.................... 	       pow10 = pow10*10; 
....................                result += (c - '0')/pow10; 
....................                c = s[ptr++]; 
....................            } 
....................         } 
....................  
.................... 	if (sign == 1) 
....................    	  result = -1*result; 
....................  
.................... 	return(result); 
.................... } 
....................  
.................... int abs(signed int i) 
.................... { 
....................    int r; 
....................  
....................    r = (i < 0) ? -i : i; 
....................    return(r); 
.................... } 
....................  
.................... long labs(signed long l) 
.................... { 
....................    long r; 
....................  
....................    r = (l < 0) ? -l : l; 
....................    return(r); 
.................... } 
....................  
.................... /************************************************************/ 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
.................... 	int sign, base, ptr; 
.................... 	char c; 
....................  
....................    ptr=0; 
....................   	sign = 0; 
.................... 	base = 10; 
.................... 	result = 0; 
....................  
.................... 	do 
....................       c=s[ptr++]; 
....................    while ((c<'0'||c>'9') && c!='+' && c!='-'); 
....................  
.................... 	while ((c>='0' && c<='9') || c=='+' || c=='-') { 
....................       if (c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '0' && (s[ptr] == 'x' || s[ptr] == 'X')) { 
....................          base = 16; 
....................          c = s[ptr+1]; 
....................          ptr+=2; 
....................       } 
....................  
....................       if (base == 10) 
....................          while (c >= '0' && c <= '9') { 
....................             result = 10*result + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................       if (base == 16) 
....................          while ((c>='0'&&c<='9')||(c>='a'&&c<='f')||(c>='A'&&c<='F')) { 
....................             c = TOUPPER(c); 
....................  
....................             if (c >= '0' && c <= '9') 
....................                result = 16*result + c - '0'; 
....................  
....................             if (c >= 'A' && c <= 'F') 
....................                result = 16*result + c - 'A' + 10; 
....................  
....................             c = s[ptr++]; 
....................          } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
....................  
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
.................... 	unsigned long ur; 
....................    int sign, base, ptr; 
....................    char c; 
....................  
....................    ptr=0; 
....................   	sign = 0; 
.................... 	base = 10; 
.................... 	result = 0; 
....................    ur = 0; 
....................  
.................... 	do 
....................       c=s[ptr++]; 
....................    while ((c<'0'||c>'9') && c!='+' && c!='-'); 
....................  
.................... 	while ((c>='0' && c<='9') || c=='+' || c=='-') { 
....................       if (c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') 
....................          c = s[ptr++]; 
....................  
....................       if (c == '0' && (s[ptr] == 'x' || s[ptr] == 'X')) { 
....................          base = 16; 
.................... 	      ptr += 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (base == 10) 
....................          while (c >= '0' && c <= '9') { 
....................             result = 10*result + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................       if (base == 16) 
....................          while ((c>='0'&&c<='9')||(c>='a'&&c<='f')||(c>='A'&&c<='F')) { 
....................             if (c >= '0' && c <= '9') { 
....................                ur = 16*ur + c - '0'; 
....................                c = s[ptr++]; 
.................... 	         } 
....................  
....................      	      c = TOUPPER(c); 
....................             if (c >= 'A' && c <= 'F') { 
....................                ur = 16*ur + c - 'A' + 10; 
....................                c = s[ptr++]; 
....................             } 
....................          } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................    if (base == 16) 
....................       result = (ur <= 32767) ? ur : -(~(ur) + 1); 
....................  
....................    return(result); 
.................... } 
....................  
.................... #endif 
.................... 
.................... #include <y:\picc\examples\string.h>       
....................  //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,1997 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #include <y:\picc\examples\ctype.h> 
....................  ////        (C) Copyright 1996,1997 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... #list 
.................... 
....................  
.................... /* standard template: char *strcat(char *s1, const char *s2) */ 
....................  
.................... char strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; s++); 
....................    while ((*s = *s2) != '\0') 
....................    { 
....................        s++; 
....................        s2++; 
....................    } 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s1 */ 
....................  
.................... char strchr(char *s, int c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s1 */ 
....................  
.................... char strrchr(char *s, int c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
....................  
.................... /*****************************************************************/ 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int strncmp(char *s1, char *s2, int n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(ISALPHA(*s1)&&ISALPHA(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /***************************************************************/ 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) */ 
....................  
.................... char strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) 
.................... 	  *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char strncpy(char *s1, char *s2, int n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
....................  
.................... /***************************************************************/ 
....................  
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... int strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
....................  
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... int strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
.................... 	 if (*sc2 == '\0') 
.................... 	    return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
....................  
.................... /***************************************************************/ 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... int strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /***************************************************************/ 
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /****************************************************************/ 
....................  
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
.................... /****************************************************************/ 
....................  
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string */ 
....................  
.................... char strstr(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    if (*s2 == 0) 
....................          return(s1); 
....................    for (; s1 = strchr(s1, *s2); s1++) 
....................    { 
....................       for (sc1 = s1, sc2 = s2; ; sc1++, sc2++) 
....................          if (*sc2 == 0) 
.................... 	    return(s1); 
....................          else if (*sc1 != *sc2) 
....................             break; 
....................    } 
....................    return(0); 
.................... } 
....................  
.................... /************************************************************/ 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... 
....................  
.................... #byte port_a=5 
.................... #byte port_b=6 
....................  
....................  
.................... #use delay (clock=20000000) 
....................  
.................... //#fuses HS,NOWDT,NOPROTECT,PUT 
....................  
.................... void PllProgram (long n, long r, int a); 
.................... char frec (int fr); 
.................... void frecQuery (int fr); 
....................  
.................... #define EE_N	0 
.................... #define EE_R	2 
.................... #define EE_A	4 
....................  
.................... void main (void) 
.................... {    
.................... 	char h,l; 
.................... 	long n; 
.................... 	long a; 
.................... 	long r; 
*
0042:  CLRF   04
0043:  MOVLW  1F
0044:  ANDWF  03,F
0045:  CLRF   11
....................  
.................... 	h=read_eeprom (EE_N+1); 
0046:  MOVLW  01
0047:  MOVWF  09
0048:  BSF    03,5
0049:  BSF    08,0
004A:  BCF    03,5
004B:  MOVF   08,W
004C:  MOVWF  12
.................... 	l=read_eeprom (EE_N); 
004D:  CLRF   09
004E:  BSF    03,5
004F:  BSF    08,0
0050:  BCF    03,5
0051:  MOVF   08,W
0052:  MOVWF  13
.................... 	n=MAKEWORD (h,l); 
0053:  CLRF   1B
0054:  MOVF   12,W
0055:  MOVWF  1A
0056:  MOVF   1A,W
0057:  MOVWF  0F
0058:  CLRW
0059:  MOVWF  0C
005A:  MOVF   0F,W
005B:  MOVWF  15
005C:  MOVF   0C,W
005D:  IORWF  13,W
005E:  MOVWF  14
....................  
.................... 	h=read_eeprom (EE_R+1); 
005F:  MOVLW  03
0060:  MOVWF  09
0061:  BSF    03,5
0062:  BSF    08,0
0063:  BCF    03,5
0064:  MOVF   08,W
0065:  MOVWF  12
.................... 	l=read_eeprom (EE_R); 
0066:  MOVLW  02
0067:  MOVWF  09
0068:  BSF    03,5
0069:  BSF    08,0
006A:  BCF    03,5
006B:  MOVF   08,W
006C:  MOVWF  13
.................... 	r=MAKEWORD (h,l); 
006D:  CLRF   1B
006E:  MOVF   12,W
006F:  MOVWF  1A
0070:  MOVF   1A,W
0071:  MOVWF  0F
0072:  CLRW
0073:  MOVWF  0C
0074:  MOVF   0F,W
0075:  MOVWF  19
0076:  MOVF   0C,W
0077:  IORWF  13,W
0078:  MOVWF  18
....................  
.................... 	h=read_eeprom (EE_A+1); 
0079:  MOVLW  05
007A:  MOVWF  09
007B:  BSF    03,5
007C:  BSF    08,0
007D:  BCF    03,5
007E:  MOVF   08,W
007F:  MOVWF  12
.................... 	l=read_eeprom (EE_A); 
0080:  MOVLW  04
0081:  MOVWF  09
0082:  BSF    03,5
0083:  BSF    08,0
0084:  BCF    03,5
0085:  MOVF   08,W
0086:  MOVWF  13
.................... 	a=MAKEWORD (h,l); 
0087:  CLRF   1B
0088:  MOVF   12,W
0089:  MOVWF  1A
008A:  MOVF   1A,W
008B:  MOVWF  0F
008C:  CLRW
008D:  MOVWF  0C
008E:  MOVF   0F,W
008F:  MOVWF  17
0090:  MOVF   0C,W
0091:  IORWF  13,W
0092:  MOVWF  16
....................  
....................  
.................... 	PllProgram (n,r,LOBYTE(a)); 
0093:  MOVF   15,W
0094:  MOVWF  1B
0095:  MOVF   14,W
0096:  MOVWF  1A
0097:  MOVF   19,W
0098:  MOVWF  1D
0099:  MOVF   18,W
009A:  MOVWF  1C
009B:  MOVF   16,W
009C:  MOVWF  1E
009D:  GOTO   02A
.................... 	while (1); 
009E:  GOTO   09E
.................... } 
....................  
009F:  SLEEP
.................... void LoadEnable() 
.................... { 
.................... 	output_high(PIN_A1); 
*
0021:  BSF    03,5
0022:  BCF    05,1
0023:  BCF    03,5
0024:  BSF    05,1
.................... 	output_low (PIN_A1);	 
0025:  BSF    03,5
0026:  BCF    05,1
0027:  BCF    03,5
0028:  BCF    05,1
0029:  RETLW  00
.................... } 
....................  
.................... void Write (int bt) 
.................... {                     
.................... 	int n; 
.................... 	 
.................... 	for (n=0;n<8;n++) 
*
0004:  CLRF   21
0005:  MOVLW  08
0006:  SUBWF  21,W
0007:  BTFSC  03,0
0008:  GOTO   020
.................... 	{ 
.................... 		output_bit (PIN_A0,shift_left (&bt,1,0)); 
0009:  BCF    03,0
000A:  RLF    20,F
000B:  BTFSC  03,0
000C:  GOTO   00F
000D:  BCF    05,0
000E:  GOTO   010
000F:  BSF    05,0
0010:  BSF    03,5
0011:  BCF    05,0
.................... 		output_high (PIN_A2);	//Clock 
0012:  BCF    05,2
0013:  BCF    03,5
0014:  BSF    05,2
.................... 		delay_us(1); 
0015:  NOP
0016:  NOP
0017:  NOP
0018:  NOP
0019:  NOP
.................... 		output_low (PIN_A2);	//Clock 
001A:  BSF    03,5
001B:  BCF    05,2
001C:  BCF    03,5
001D:  BCF    05,2
.................... 	} 
001E:  INCF   21,F
001F:  GOTO   005
0020:  RETLW  00
.................... } 
....................  
.................... void PllProgram (long n, long r, int a) 
.................... { 
.................... 	Write (HIBYTE(r)); 
*
002A:  MOVF   1D,W
002B:  MOVWF  1F
002C:  CLRF   20
002D:  MOVF   1F,W
002E:  MOVWF  20
002F:  CALL   004
.................... 	Write (LOBYTE(r)); 
0030:  MOVF   1C,W
0031:  MOVWF  20
0032:  CALL   004
.................... 	LoadEnable(); 
0033:  CALL   021
.................... 	 
.................... 	Write (HIBYTE(n)); 
0034:  MOVF   1B,W
0035:  MOVWF  1F
0036:  CLRF   20
0037:  MOVF   1F,W
0038:  MOVWF  20
0039:  CALL   004
.................... 	Write (LOBYTE(n)); 
003A:  MOVF   1A,W
003B:  MOVWF  20
003C:  CALL   004
.................... 	Write (a); 
003D:  MOVF   1E,W
003E:  MOVWF  20
003F:  CALL   004
.................... 	LoadEnable(); 
0040:  CALL   021
0041:  GOTO   09E
.................... } 
....................  
