MPASM

CCS PCM C Compiler, Version 2.717, 9374

               Filename: Z:\vph1\TX018\TX018.LST

               ROM used: 99 (2%)
                         Largest free fragment is 2048
               RAM used: 15 (8%) at main() level
                         23 (12%) worst case
               Stack:    2 locations

0000 3000           00001 MOVLW  00
0001 008A           00002 MOVWF  0A
0002 2845           00003 GOTO   045
0003 0000           00004 NOP
0000                00005 ....................  /////////////////////////////////////////////////////// 
0000                00006 .................... // 
0000                00007 .................... // PROGRAMA PARA EL MODEM RM018 
0000                00008 .................... //--------------------------------------------------------- 
0000                00009 .................... // 
0000                00010 .................... // Parametros para el compilador: +FM +t 
0000                00011 .................... // 
0000                00012 .................... //  
0000                00013 .................... //////////////////////////////////////////////////////////// 
0000                00014 ....................  
0000                00015 .................... #include <y:\picc\examples\16c63.h> 
0000                00016 ....................  //////// Standard Header file for the PIC16C63 device //////// 
0000                00017 .................... #device PIC16C63 
0000                00160 .................... #list 
0000                00161 .................... 
0000                00162 .................... //#include <y:\picc\examples\16c54.h> 
0000                00163 .................... #include <y:\picc\examples\ctype.h> 
0000                00164 ....................  ////        (C) Copyright 1996,1997 Custom Computer Services            //// 
0000                00165 .................... //// This source code may only be used by licensed users of the CCS C   //// 
0000                00166 .................... //// compiler.  This source code may only be distributed to other       //// 
0000                00167 .................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
0000                00168 .................... //// or distribution is permitted without written permission.           //// 
0000                00169 .................... //// Derivative programs created using this software in object code     //// 
0000                00170 .................... //// form are not restricted in any way.                                //// 
0000                00171 .................... //////////////////////////////////////////////////////////////////////////// 
0000                00203 .................... #list 
0000                00204 .................... 
0000                00205 .................... #include <y:\picc\examples\stdlib.h> 
0000                00206 ....................  ////        (C) Copyright 1996,1997 Custom Computer Services            //// 
0000                00207 .................... //// This source code may only be used by licensed users of the CCS C   //// 
0000                00208 .................... //// compiler.  This source code may only be distributed to other       //// 
0000                00209 .................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
0000                00210 .................... //// or distribution is permitted without written permission.           //// 
0000                00211 .................... //// Derivative programs created using this software in object code     //// 
0000                00212 .................... //// form are not restricted in any way.                                //// 
0000                00213 .................... //////////////////////////////////////////////////////////////////////////// 
0000                00214 ....................  
0000                00215 .................... #ifndef _stdlib_ 
0000                00216 ....................  
0000                00217 .................... #define _stdlib_ true 
0000                00218 ....................  
0000                00219 .................... float atof(char * s) { 
0000                00220 .................... 	float pow10; 
0000                00221 ....................         float result; 
0000                00222 .................... 	int sign, point; 
0000                00223 .................... 	char c; 
0000                00224 ....................         int ptr; 
0000                00225 ....................  
0000                00226 ....................         ptr=0; 
0000                00227 ....................    	sign = 0; 
0000                00228 .................... 	point = 0; 
0000                00229 .................... 	pow10 = 1.0; 
0000                00230 ....................    	result = 0.0; 
0000                00231 ....................  
0000                00232 .................... 	do 
0000                00233 ....................           c=s[ptr++]; 
0000                00234 ....................         while ((c<'0'||c>'9') && c!='+' && c!='-' && c!='.'); 
0000                00235 ....................  
0000                00236 .................... 	while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
0000                00237 ....................            if(c == '-') { 
0000                00238 ....................               sign = 1; 
0000                00239 ....................               c = s[ptr++]; 
0000                00240 ....................            } 
0000                00241 ....................  
0000                00242 ....................            while((c >= '0' && c <= '9') && point == 0) { 
0000                00243 ....................               result = 10*result + c - '0'; 
0000                00244 ....................               c = s[ptr++]; 
0000                00245 ....................            } 
0000                00246 ....................  
0000                00247 ....................            if (c == '.') { 
0000                00248 ....................               point = 1; 
0000                00249 ....................               c = s[ptr++]; 
0000                00250 ....................            } 
0000                00251 ....................  
0000                00252 .................... 	   while((c >= '0' && c <= '9') && point == 1) { 
0000                00253 .................... 	       pow10 = pow10*10; 
0000                00254 ....................                result += (c - '0')/pow10; 
0000                00255 ....................                c = s[ptr++]; 
0000                00256 ....................            } 
0000                00257 ....................         } 
0000                00258 ....................  
0000                00259 .................... 	if (sign == 1) 
0000                00260 ....................    	  result = -1*result; 
0000                00261 ....................  
0000                00262 .................... 	return(result); 
0000                00263 .................... } 
0000                00264 ....................  
0000                00265 .................... int abs(signed int i) 
0000                00266 .................... { 
0000                00267 ....................    int r; 
0000                00268 ....................  
0000                00269 ....................    r = (i < 0) ? -i : i; 
0000                00270 ....................    return(r); 
0000                00271 .................... } 
0000                00272 ....................  
0000                00273 .................... long labs(signed long l) 
0000                00274 .................... { 
0000                00275 ....................    long r; 
0000                00276 ....................  
0000                00277 ....................    r = (l < 0) ? -l : l; 
0000                00278 ....................    return(r); 
0000                00279 .................... } 
0000                00280 ....................  
0000                00281 .................... /************************************************************/ 
0000                00282 ....................  
0000                00283 .................... signed int atoi(char *s) 
0000                00284 .................... { 
0000                00285 ....................    signed int result; 
0000                00286 .................... 	int sign, base, ptr; 
0000                00287 .................... 	char c; 
0000                00288 ....................  
0000                00289 ....................    ptr=0; 
0000                00290 ....................   	sign = 0; 
0000                00291 .................... 	base = 10; 
0000                00292 .................... 	result = 0; 
0000                00293 ....................  
0000                00294 .................... 	do 
0000                00295 ....................       c=s[ptr++]; 
0000                00296 ....................    while ((c<'0'||c>'9') && c!='+' && c!='-'); 
0000                00297 ....................  
0000                00298 .................... 	while ((c>='0' && c<='9') || c=='+' || c=='-') { 
0000                00299 ....................       if (c == '-') { 
0000                00300 ....................          sign = 1; 
0000                00301 ....................          c = s[ptr++]; 
0000                00302 ....................       } 
0000                00303 ....................  
0000                00304 ....................       if (c == '0' && (s[ptr] == 'x' || s[ptr] == 'X')) { 
0000                00305 ....................          base = 16; 
0000                00306 ....................          c = s[ptr+1]; 
0000                00307 ....................          ptr+=2; 
0000                00308 ....................       } 
0000                00309 ....................  
0000                00310 ....................       if (base == 10) 
0000                00311 ....................          while (c >= '0' && c <= '9') { 
0000                00312 ....................             result = 10*result + c - '0'; 
0000                00313 ....................             c = s[ptr++]; 
0000                00314 ....................          } 
0000                00315 ....................  
0000                00316 ....................       if (base == 16) 
0000                00317 ....................          while ((c>='0'&&c<='9')||(c>='a'&&c<='f')||(c>='A'&&c<='F')) { 
0000                00318 ....................             c = TOUPPER(c); 
0000                00319 ....................  
0000                00320 ....................             if (c >= '0' && c <= '9') 
0000                00321 ....................                result = 16*result + c - '0'; 
0000                00322 ....................  
0000                00323 ....................             if (c >= 'A' && c <= 'F') 
0000                00324 ....................                result = 16*result + c - 'A' + 10; 
0000                00325 ....................  
0000                00326 ....................             c = s[ptr++]; 
0000                00327 ....................          } 
0000                00328 ....................    } 
0000                00329 ....................  
0000                00330 ....................    if (sign == 1 && base == 10) 
0000                00331 ....................        result = -result; 
0000                00332 ....................  
0000                00333 ....................    return(result); 
0000                00334 .................... } 
0000                00335 ....................  
0000                00336 ....................  
0000                00337 ....................  
0000                00338 .................... signed long atol(char *s) 
0000                00339 .................... { 
0000                00340 ....................    signed long result; 
0000                00341 .................... 	unsigned long ur; 
0000                00342 ....................    int sign, base, ptr; 
0000                00343 ....................    char c; 
0000                00344 ....................  
0000                00345 ....................    ptr=0; 
0000                00346 ....................   	sign = 0; 
0000                00347 .................... 	base = 10; 
0000                00348 .................... 	result = 0; 
0000                00349 ....................    ur = 0; 
0000                00350 ....................  
0000                00351 .................... 	do 
0000                00352 ....................       c=s[ptr++]; 
0000                00353 ....................    while ((c<'0'||c>'9') && c!='+' && c!='-'); 
0000                00354 ....................  
0000                00355 .................... 	while ((c>='0' && c<='9') || c=='+' || c=='-') { 
0000                00356 ....................       if (c == '-') { 
0000                00357 ....................          sign = 1; 
0000                00358 ....................          c = s[ptr++]; 
0000                00359 ....................       } 
0000                00360 ....................  
0000                00361 ....................       if (c == '+') 
0000                00362 ....................          c = s[ptr++]; 
0000                00363 ....................  
0000                00364 ....................       if (c == '0' && (s[ptr] == 'x' || s[ptr] == 'X')) { 
0000                00365 ....................          base = 16; 
0000                00366 .................... 	      ptr += 1; 
0000                00367 ....................          c = s[ptr++]; 
0000                00368 ....................       } 
0000                00369 ....................  
0000                00370 ....................       if (base == 10) 
0000                00371 ....................          while (c >= '0' && c <= '9') { 
0000                00372 ....................             result = 10*result + c - '0'; 
0000                00373 ....................             c = s[ptr++]; 
0000                00374 ....................          } 
0000                00375 ....................  
0000                00376 ....................       if (base == 16) 
0000                00377 ....................          while ((c>='0'&&c<='9')||(c>='a'&&c<='f')||(c>='A'&&c<='F')) { 
0000                00378 ....................             if (c >= '0' && c <= '9') { 
0000                00379 ....................                ur = 16*ur + c - '0'; 
0000                00380 ....................                c = s[ptr++]; 
0000                00381 .................... 	         } 
0000                00382 ....................  
0000                00383 ....................      	      c = TOUPPER(c); 
0000                00384 ....................             if (c >= 'A' && c <= 'F') { 
0000                00385 ....................                ur = 16*ur + c - 'A' + 10; 
0000                00386 ....................                c = s[ptr++]; 
0000                00387 ....................             } 
0000                00388 ....................          } 
0000                00389 ....................    } 
0000                00390 ....................  
0000                00391 ....................    if (base == 10 && sign == 1) 
0000                00392 ....................       result = -result; 
0000                00393 ....................    if (base == 16) 
0000                00394 ....................       result = (ur <= 32767) ? ur : -(~(ur) + 1); 
0000                00395 ....................  
0000                00396 ....................    return(result); 
0000                00397 .................... } 
0000                00398 ....................  
0000                00399 .................... #endif 
0000                00400 .................... 
0000                00401 .................... #include <y:\picc\examples\string.h>       
0000                00402 ....................  //////////////////////////////////////////////////////////////////////////// 
0000                00403 .................... ////        (C) Copyright 1996,1997 Custom Computer Services            //// 
0000                00404 .................... //// This source code may only be used by licensed users of the CCS C   //// 
0000                00405 .................... //// compiler.  This source code may only be distributed to other       //// 
0000                00406 .................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
0000                00407 .................... //// or distribution is permitted without written permission.           //// 
0000                00408 .................... //// Derivative programs created using this software in object code     //// 
0000                00409 .................... //// form are not restricted in any way.                                //// 
0000                00410 .................... //////////////////////////////////////////////////////////////////////////// 
0000                00411 ....................  
0000                00412 .................... #include <y:\picc\examples\ctype.h> 
0000                00413 ....................  ////        (C) Copyright 1996,1997 Custom Computer Services            //// 
0000                00414 .................... //// This source code may only be used by licensed users of the CCS C   //// 
0000                00415 .................... //// compiler.  This source code may only be distributed to other       //// 
0000                00416 .................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
0000                00417 .................... //// or distribution is permitted without written permission.           //// 
0000                00418 .................... //// Derivative programs created using this software in object code     //// 
0000                00419 .................... //// form are not restricted in any way.                                //// 
0000                00420 .................... //////////////////////////////////////////////////////////////////////////// 
0000                00452 .................... #list 
0000                00453 .................... 
0000                00454 ....................  
0000                00455 .................... /* standard template: char *strcat(char *s1, const char *s2) */ 
0000                00456 ....................  
0000                00457 .................... char strcat(char *s1, char *s2) 
0000                00458 .................... { 
0000                00459 ....................    char *s; 
0000                00460 ....................  
0000                00461 ....................    for (s = s1; *s != '\0'; s++); 
0000                00462 ....................    while ((*s = *s2) != '\0') 
0000                00463 ....................    { 
0000                00464 ....................        s++; 
0000                00465 ....................        s2++; 
0000                00466 ....................    } 
0000                00467 ....................    return(s1); 
0000                00468 .................... } 
0000                00469 ....................  
0000                00470 .................... /***********************************************************/ 
0000                00471 ....................  
0000                00472 .................... /* standard template: char *strchr(const char *s, int c). 
0000                00473 ....................    Finds first occurrence of c in s1 */ 
0000                00474 ....................  
0000                00475 .................... char strchr(char *s, int c) 
0000                00476 .................... { 
0000                00477 ....................    for (; *s != c; s++) 
0000                00478 ....................       if (*s == '\0') 
0000                00479 ....................          return(0); 
0000                00480 ....................    return(s); 
0000                00481 .................... } 
0000                00482 ....................  
0000                00483 .................... /* standard template: char *strrchr(const char *s, int c). 
0000                00484 ....................    Finds last occurrence of c in s1 */ 
0000                00485 ....................  
0000                00486 .................... char strrchr(char *s, int c) 
0000                00487 .................... { 
0000                00488 ....................    char *p; 
0000                00489 ....................  
0000                00490 ....................    for (p = 0; ; s++) 
0000                00491 ....................    { 
0000                00492 ....................       if (*s == c) 
0000                00493 ....................          p = s; 
0000                00494 ....................       if (*s == '\0') 
0000                00495 ....................          return(p); 
0000                00496 ....................    } 
0000                00497 .................... } 
0000                00498 ....................  
0000                00499 .................... /*****************************************************************/ 
0000                00500 ....................  
0000                00501 .................... /* standard template: int strcmp(const char *s1, const char *s2). 
0000                00502 ....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
0000                00503 ....................  
0000                00504 .................... signed int strcmp(char *s1, char *s2) 
0000                00505 .................... { 
0000                00506 ....................    for (; *s1 == *s2; s1++, s2++) 
0000                00507 ....................       if (*s1 == '\0') 
0000                00508 ....................          return(0); 
0000                00509 ....................    return((*s1 < *s2) ? -1: 1); 
0000                00510 .................... } 
0000                00511 ....................  
0000                00512 .................... /* standard template: 
0000                00513 ....................    int strncmp(const char *s1, const char *s2, size_t n). 
0000                00514 ....................    Compares max of n characters (not following 0) from s1 to s2; 
0000                00515 ....................    returns same as strcmp */ 
0000                00516 ....................  
0000                00517 .................... signed int strncmp(char *s1, char *s2, int n) 
0000                00518 .................... { 
0000                00519 ....................    for (; n > 0; s1++, s2++, n--) 
0000                00520 ....................       if (*s1 != *s2) 
0000                00521 ....................          return((*s1 <*s2) ? -1: 1); 
0000                00522 ....................       else if (*s1 == '\0') 
0000                00523 ....................          return(0); 
0000                00524 ....................    return(0); 
0000                00525 .................... } 
0000                00526 ....................  
0000                00527 .................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
0000                00528 ....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
0000                00529 ....................  
0000                00530 .................... signed int stricmp(char *s1, char *s2) 
0000                00531 .................... { 
0000                00532 ....................  for(; *s1==*s2||(ISALPHA(*s1)&&ISALPHA(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
0000                00533 ....................     s1++, s2++) 
0000                00534 ....................     if (*s1 == '\0') 
0000                00535 ....................        return(0); 
0000                00536 ....................  return((*s1 < *s2) ? -1: 1); 
0000                00537 .................... } 
0000                00538 ....................  
0000                00539 .................... /***************************************************************/ 
0000                00540 ....................  
0000                00541 .................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
0000                00542 ....................    Standard template: char *strcpy(char *s1, const char *s2) */ 
0000                00543 ....................  
0000                00544 .................... char strcopy(char *s1, char *s2) 
0000                00545 .................... { 
0000                00546 ....................   char *s; 
0000                00547 ....................  
0000                00548 ....................   for (s = s1; *s2 != 0; s++, s2++) 
0000                00549 .................... 	  *s = *s2; 
0000                00550 ....................   return(s1); 
0000                00551 .................... } 
0000                00552 ....................  
0000                00553 .................... /* standard template: 
0000                00554 ....................    char *strncpy(char *s1, const char *s2, size_t n). 
0000                00555 ....................    Copies max of n characters (not following ending '\0') 
0000                00556 ....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
0000                00557 ....................  
0000                00558 .................... char strncpy(char *s1, char *s2, int n) 
0000                00559 .................... { 
0000                00560 ....................   char *s; 
0000                00561 ....................  
0000                00562 ....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
0000                00563 ....................      *s++ = *s2++; 
0000                00564 ....................   for (; n > 0; n--) 
0000                00565 ....................      *s++ = '\0'; 
0000                00566 ....................  
0000                00567 ....................   return(s1); 
0000                00568 .................... } 
0000                00569 ....................  
0000                00570 .................... /***************************************************************/ 
0000                00571 ....................  
0000                00572 .................... /* standard template: 
0000                00573 ....................    size_t strcspn(const char *s1, const char *s2). 
0000                00574 ....................    Computes length of max initial segment of s1 that 
0000                00575 ....................    consists entirely of characters NOT from s2*/ 
0000                00576 ....................  
0000                00577 .................... int strcspn(char *s1, char *s2) 
0000                00578 .................... { 
0000                00579 ....................    char *sc1, *sc2; 
0000                00580 ....................  
0000                00581 ....................    for (sc1 = s1; *sc1 != 0; sc1++) 
0000                00582 ....................       for (sc2 = s2; *sc2 != 0; sc2++) 
0000                00583 ....................          if (*sc1 == *sc2) 
0000                00584 ....................             return(sc1 - s1); 
0000                00585 ....................    return(sc1 - s1); 
0000                00586 .................... } 
0000                00587 ....................  
0000                00588 .................... /* computes length of max initial segment of s1 consisting 
0000                00589 ....................    entirely of characters from s2 */ 
0000                00590 ....................  
0000                00591 .................... int strspn(char *s1, char *s2) 
0000                00592 .................... { 
0000                00593 ....................    char *sc1, *sc2; 
0000                00594 ....................  
0000                00595 ....................    for (sc1 = s1; *sc1 != 0; sc1++) 
0000                00596 ....................       for (sc2 = s2; ; sc2++) 
0000                00597 .................... 	 if (*sc2 == '\0') 
0000                00598 .................... 	    return(sc1 - s1); 
0000                00599 ....................          else if (*sc1 == *sc2) 
0000                00600 ....................             break; 
0000                00601 ....................    return(sc1 - s1); 
0000                00602 .................... } 
0000                00603 ....................  
0000                00604 .................... /***************************************************************/ 
0000                00605 ....................  
0000                00606 .................... /* standard template: size_t strlen(const char *s). 
0000                00607 ....................    Computes length of s1 (preceding terminating 0) */ 
0000                00608 ....................  
0000                00609 .................... int strlen(char *s) 
0000                00610 .................... { 
0000                00611 ....................    char *sc; 
0000                00612 ....................  
0000                00613 ....................    for (sc = s; *sc != 0; sc++); 
0000                00614 ....................    return(sc - s); 
0000                00615 .................... } 
0000                00616 ....................  
0000                00617 .................... /***************************************************************/ 
0000                00618 ....................  
0000                00619 .................... /* standard template: char *strlwr(char *s). 
0000                00620 ....................    Replaces uppercase letters by lowercase; 
0000                00621 ....................    returns pointer to new string s */ 
0000                00622 ....................  
0000                00623 .................... char strlwr(char *s) 
0000                00624 .................... { 
0000                00625 ....................    char *p; 
0000                00626 ....................  
0000                00627 ....................    for (p = s; *p != '\0'; p++) 
0000                00628 ....................       if (*p >= 'A' && *p <='Z') 
0000                00629 ....................          *p += 'a' - 'A'; 
0000                00630 ....................    return(s); 
0000                00631 .................... } 
0000                00632 ....................  
0000                00633 .................... /****************************************************************/ 
0000                00634 ....................  
0000                00635 .................... /* standard template: 
0000                00636 ....................    char *strpbrk(const char *s1, const char *s2). 
0000                00637 ....................    Locates first occurence of any character from s2 in s1; 
0000                00638 ....................    returns s1 if s2 is empty string */ 
0000                00639 ....................  
0000                00640 .................... char strpbrk(char *s1, char *s2) 
0000                00641 .................... { 
0000                00642 ....................    char *sc1, *sc2; 
0000                00643 ....................  
0000                00644 ....................    for (sc1 = s1; *sc1 != 0; sc1++) 
0000                00645 ....................       for (sc2 = s2; *sc2 != 0; sc2++) 
0000                00646 ....................          if (*sc1 == *sc2) 
0000                00647 ....................             return(sc1); 
0000                00648 ....................    return(0); 
0000                00649 .................... } 
0000                00650 ....................  
0000                00651 .................... /****************************************************************/ 
0000                00652 ....................  
0000                00653 .................... /* standard template: 
0000                00654 ....................    char *strstr(const char *s1, const char *s2); 
0000                00655 ....................    Locates first occurence of character sequence s2 in s1; 
0000                00656 ....................    returns 0 if s2 is empty string */ 
0000                00657 ....................  
0000                00658 .................... char strstr(char *s1, char *s2) 
0000                00659 .................... { 
0000                00660 ....................    char *sc1, *sc2; 
0000                00661 ....................  
0000                00662 ....................    if (*s2 == 0) 
0000                00663 ....................          return(s1); 
0000                00664 ....................    for (; s1 = strchr(s1, *s2); s1++) 
0000                00665 ....................    { 
0000                00666 ....................       for (sc1 = s1, sc2 = s2; ; sc1++, sc2++) 
0000                00667 ....................          if (*sc2 == 0) 
0000                00668 .................... 	    return(s1); 
0000                00669 ....................          else if (*sc1 != *sc2) 
0000                00670 ....................             break; 
0000                00671 ....................    } 
0000                00672 ....................    return(0); 
0000                00673 .................... } 
0000                00674 ....................  
0000                00675 .................... /************************************************************/ 
0000                00676 ....................  
0000                00677 .................... /* standard template: char *strtok(char *s1, const char *s2). 
0000                00678 ....................  
0000                00679 ....................    Finds next token in s1 delimited by a character from separator 
0000                00680 ....................    string s2 (which can be different from call to call).  First call 
0000                00681 ....................    starts at beginning of s1 searching for first character NOT 
0000                00682 ....................    contained in s2; returns 0 if none is found. 
0000                00683 ....................    If one is found, it is the start of first token (return value). 
0000                00684 ....................    Function then searches from there for a character contained in s2. 
0000                00685 ....................    If none is found, current token extends to end of s1, and subsequent 
0000                00686 ....................    searches for a token will return 0.  If one is found, it is 
0000                00687 ....................    overwritten by '\0', which terminates current token.  Function saves 
0000                00688 ....................    pointer to following character from which next search will start. 
0000                00689 ....................    Each subsequent call, with 0 as first argument, starts searching 
0000                00690 ....................    from saved pointer */ 
0000                00691 ....................  
0000                00692 .................... char strtok(char *s1, char *s2) 
0000                00693 .................... { 
0000                00694 ....................    char *beg, *end; 
0000                00695 ....................    static char *save; 
0000                00696 ....................  
0000                00697 ....................    beg = (s1)? s1: save; 
0000                00698 ....................    beg += strspn(beg, s2); 
0000                00699 ....................    if (*beg == '\0') 
0000                00700 ....................    { 
0000                00701 ....................       *save = ' '; 
0000                00702 ....................       return(0); 
0000                00703 ....................    } 
0000                00704 ....................    end = strpbrk(beg, s2); 
0000                00705 ....................    if (*end != '\0') 
0000                00706 ....................    { 
0000                00707 ....................       *end = '\0'; 
0000                00708 ....................       end++; 
0000                00709 ....................    } 
0000                00710 ....................    save = end; 
0000                00711 ....................    return(beg); 
0000                00712 .................... } 
0000                00713 ....................  
0000                00714 .................... 
0000                00715 ....................  
0000                00716 .................... #byte port_a=5 
0000                00717 .................... #byte port_b=6 
0000                00718 ....................  
0000                00719 ....................  
0000                00720 .................... #use delay (clock=20000000) 
0000                00721 ....................  
0000                00722 .................... //#fuses HS,NOWDT,NOPROTECT,PUT 
0000                00723 ....................  
0000                00724 .................... void PllProgram (long n, long r, int a); 
0000                00725 .................... char frec (int fr); 
0000                00726 .................... void frecQuery (int fr); 
0000                00727 ....................  
0000                00728 .................... #define EE_N	0 
0000                00729 .................... #define EE_R	2 
0000                00730 .................... #define EE_A	4 
0000                00731 ....................  
0000                00732 .................... void main (void) 
0000                00733 .................... {    
0000                00734 .................... 	// CALCULADO CON MD2.EXE 
0000                00735 ....................  
0000                00736 .................... 	// FRECUENCIA: 868975 
0000                00737 .................... 	// PRESCALER: 64 
0000                00738 .................... 	// FREC.REF: 25 
0000                00739 .................... 	// OSCILADOR: 4000 
0000                00740 ....................  
0000                00741 .................... 	char h,l; 
0000                00742 .................... 	long n; 
0000                00743 .................... 	long a; 
0000                00744 .................... 	long r; 
0045 0184           00745 CLRF   04
0046 301F           00746 MOVLW  1F
0047 0583           00747 ANDWF  03,F
0048 01A5           00748 CLRF   25
0049 30FF           00749 MOVLW  FF
004A 00A6           00750 MOVWF  26
0000                00751 ....................      
0000                00752 .................... 	n=543; 
004B 3002           00753 MOVLW  02
004C 00AA           00754 MOVWF  2A
004D 301F           00755 MOVLW  1F
004E 00A9           00756 MOVWF  29
0000                00757 .................... 	a=14; 
004F 01AC           00758 CLRF   2C
0050 300E           00759 MOVLW  0E
0051 00AB           00760 MOVWF  2B
0000                00761 .................... 	r=321; 
0052 3001           00762 MOVLW  01
0053 00AE           00763 MOVWF  2E
0054 3041           00764 MOVLW  41
0055 00AD           00765 MOVWF  2D
0000                00766 .................... 	 
0000                00767 .................... 	PllProgram (n,r,LOBYTE(a)); 
0056 082A           00768 MOVF   2A,W
0057 00B0           00769 MOVWF  30
0058 0829           00770 MOVF   29,W
0059 00AF           00771 MOVWF  2F
005A 082E           00772 MOVF   2E,W
005B 00B2           00773 MOVWF  32
005C 082D           00774 MOVF   2D,W
005D 00B1           00775 MOVWF  31
005E 082B           00776 MOVF   2B,W
005F 00B3           00777 MOVWF  33
0060 282C           00778 GOTO   02C
0000                00779 .................... 	while (1); 
0061 2861           00780 GOTO   061
0000                00781 .................... } 
0000                00782 ....................  
0062 0063           00783 SLEEP
0000                00784 .................... void LoadEnable() 
0000                00785 .................... { 
0000                00786 .................... 	output_high(PIN_A2); 
0023 1683           00787 BSF    03,5
0024 1105           00788 BCF    05,2
0025 1283           00789 BCF    03,5
0026 1505           00790 BSF    05,2
0000                00791 .................... 	output_low (PIN_A2);	 
0027 1683           00792 BSF    03,5
0028 1105           00793 BCF    05,2
0029 1283           00794 BCF    03,5
002A 1105           00795 BCF    05,2
002B 3400           00796 RETLW  00
0000                00797 .................... } 
0000                00798 ....................  
0000                00799 .................... void Write (int bt) 
0000                00800 .................... {                     
0000                00801 .................... 	int n; 
0000                00802 .................... 	 
0000                00803 .................... 	for (n=0;n<8;n++) 
0004 01B6           00804 CLRF   36
0005 3008           00805 MOVLW  08
0006 0236           00806 SUBWF  36,W
0007 1803           00807 BTFSC  03,0
0008 2822           00808 GOTO   022
0000                00809 .................... 	{ 
0000                00810 .................... 		output_bit (PIN_C5,shift_left (&bt,1,0)); 
0009 1003           00811 BCF    03,0
000A 0DB5           00812 RLF    35,F
000B 1803           00813 BTFSC  03,0
000C 280F           00814 GOTO   00F
000D 1287           00815 BCF    07,5
000E 2810           00816 GOTO   010
000F 1687           00817 BSF    07,5
0010 12A6           00818 BCF    26,5
0011 0826           00819 MOVF   26,W
0012 0067           00820 TRIS   7
0000                00821 .................... 		output_high (PIN_C3);	//Clock 
0013 11A6           00822 BCF    26,3
0014 0826           00823 MOVF   26,W
0015 0067           00824 TRIS   7
0016 1587           00825 BSF    07,3
0000                00826 .................... 		delay_us(1); 
0017 0000           00827 NOP
0018 0000           00828 NOP
0019 0000           00829 NOP
001A 0000           00830 NOP
001B 0000           00831 NOP
0000                00832 .................... 		output_low (PIN_C3);	//Clock 
001C 11A6           00833 BCF    26,3
001D 0826           00834 MOVF   26,W
001E 0067           00835 TRIS   7
001F 1187           00836 BCF    07,3
0000                00837 .................... 	} 
0020 0AB6           00838 INCF   36,F
0021 2805           00839 GOTO   005
0022 3400           00840 RETLW  00
0000                00841 .................... } 
0000                00842 ....................  
0000                00843 .................... void PllProgram (long n, long r, int a) 
0000                00844 .................... { 
0000                00845 .................... 	Write (HIBYTE(r)); 
002C 0832           00846 MOVF   32,W
002D 00B4           00847 MOVWF  34
002E 01B5           00848 CLRF   35
002F 0834           00849 MOVF   34,W
0030 00B5           00850 MOVWF  35
0031 2004           00851 CALL   004
0000                00852 .................... 	Write (LOBYTE(r)); 
0032 0831           00853 MOVF   31,W
0033 00B5           00854 MOVWF  35
0034 2004           00855 CALL   004
0000                00856 .................... 	LoadEnable(); 
0035 2023           00857 CALL   023
0000                00858 .................... 	 
0000                00859 .................... 	Write (HIBYTE(n)); 
0036 0830           00860 MOVF   30,W
0037 00B4           00861 MOVWF  34
0038 01B5           00862 CLRF   35
0039 0834           00863 MOVF   34,W
003A 00B5           00864 MOVWF  35
003B 2004           00865 CALL   004
0000                00866 .................... 	Write (LOBYTE(n)); 
003C 082F           00867 MOVF   2F,W
003D 00B5           00868 MOVWF  35
003E 2004           00869 CALL   004
0000                00870 .................... 	Write (a); 
003F 0833           00871 MOVF   33,W
0040 00B5           00872 MOVWF  35
0041 2004           00873 CALL   004
0000                00874 .................... 	LoadEnable(); 
0042 2023           00875 CALL   023
0043 118A           00876 BCF    0A,3
0044 2861           00877 GOTO   061
0000                00878 .................... } 
0000                00879 ....................  

SYMBOL TABLE
  LABEL                             VALUE

PORT_A                            00000005
PORT_B                            00000006
TIMER_1_LOW                       0000000E
TIMER_1_HIGH                      0000000F
TIMER_2                           00000011
CCP_1                             00000015
CCP_1_LOW                         00000015
CCP_1_HIGH                        00000016
CCP_2                             0000001B
CCP_2_LOW                         0000001B
CCP_2_HIGH                        0000001C
_RETURN_                          00000021
STRTOK.SAVE                       00000025
TRIS_C                            00000026
MAIN.H                            00000027
MAIN.L                            00000028
MAIN.N                            00000029
MAIN.A                            0000002B
MAIN.R                            0000002D
PLLPROGRAM.N                      0000002F
PLLPROGRAM.R                      00000031
PLLPROGRAM.A                      00000033
WRITE.BT                          00000035
WRITE.N                           00000036
MAIN                              00000045
LOADENABLE                        00000023
WRITE                             00000004
PLLPROGRAM                        0000002C

MEMORY USAGE
